/**	Este modulo ofrece todo el control de la base de datos en mysql	del servidor toollife, es decir, no solo consultas si no tambien	realizar las tareas de borrado, modificacion e inserccion.*///Module dependencies.var mysql = require('mysql');require('Array.prototype.forEachAsync');var utils = require('./Utils.js');var async = require('async');var check = require('validator').check;var mail = require('./MailController.js'); var color = require("ansi-color").set;//Variablesvar tramites = []; //Array de Timeout de tramites sin validarvar monitor_Tramites = null;var monitor_Cookies_Caducadas = null;//Funciones controladorasfunction verificarUser(handlers, handlerCookie, req, res){  //Definicion de Variables  var user = req.body.emailLogin;  var pass = req.body.passLogin;  var cliente = crearCliente();  var query = 'CALL identificar_usuario(\'' + user + '\', \'' + pass + '\');';  cliente.query(query, function (err, results, fields) {	cliente.end(); //Cerramos la conexion	if (err){		console.log("Error DB: " + err);		handlers.error(err.message, res); //LLamar a la funcion que trata los errores	} else {		if(results.length == 0)			handlers.noValid("Usuario/contraseÒa inv·lida.", res); //LLamar a la funcion para los usuarios no validos		else {			var pathUser, idUser, isActive;			results.forEachAsync(function (next, user) {				pathUser = user.pathUser;				idUser = user.idUser;				isActive = user.isActive;				setTimeout(next, 0);			}).then(function () {				handlerCookie(idUser, req, res);				handlers.valid(pathUser, idUser, isActive, req, res);			});		}	}  });}function registrarUser(handlers, req, res){  /* Hay tres niveles de seguridad para un correcto registro:  Nivel 1: los campos deben estar correctamente introducidos  Nivel 2: no debe existir el usuario introducido, debe generarse el pathUser y el hash de tramites de code 1  Nivel 3: debe ejecutarse las sentencias SQL de registro correctamente */  async.parallel({    email: checkValue(req.body.emailR, "email", 6, 75, true),	name: checkValue(req.body.nombreR, "nombre", 1, 35, false),	surname: checkValue(req.body.apellidosR, "apellidos", 1, 75, false),	pass: checkValue(req.body.passR, "password", 5, 45, false)  }, function(err, result) { 	if(err)		handlers.error(err.message, res);	else {		if(result.email != req.body.reemailR)			handlers.error('El email y el re-email no coinciden', res);		else {			//Definicion de Variables			var email = result.email;			var pass = req.body.passR;			var name = result.name;			var surname = result.surname;			var cliente = crearCliente();					//Las funciones son ejecutadas al mismo tiempo			async.parallel({		      isValid: existsUser(cliente, email),			  generatePathUser: generatePathUser(cliente, name, surname),			  hash: createHash()			}, function(err, result) {			  if(err){				cliente.end();				if(!result.isValid) handlers.noValid(err, res); //Funcion para los usuarios no validos				else handlers.error(err, res); //Funcion para los errores			  } else {				//Cada query es ejecutada tras la anterior si no hubo ningun error				async.series({				  res1: executeQuery(cliente, 'START TRANSACTION;'),				  res2: executeQuery(cliente, 'INSERT INTO usuarios (email, password) VALUES (\'' + email + '\', \'' + pass + '\');'),				  res3: executeQuery(cliente, 'SELECT @id := u.idUser as idUser, u.isActive FROM usuarios u WHERE u.email = \'' + email + '\' and u.password = \'' + pass + '\';'),				  res4: executeQuery(cliente, 'INSERT INTO perfil VALUES (@id, \'' + name + '\', \'' + surname + '\', \'' + result.generatePathUser + '\');'),				  res5: executeQuery(cliente, 'INSERT INTO en_tramite (code, idUser, hash) VALUES (1, @id, \'' + result.hash + '\');'),				  res6: executeQuery(cliente, 'COMMIT;'),				}, function(err, results) {					cliente.end();					if(err)						handlers.error(err.message, res); 					else {						var idUser, isActive;						results.res3.forEachAsync(function (next, row) {						  idUser = row.idUser;						  isActive = row.isActive;						  setTimeout(next, 0);						}).then(function () {						  //Creamos el userDATA						  var userDATA = utils.createUserDataWithParameters(idUser, result.generatePathUser, isActive);						  utils.createDirectory(userDATA);						  						  //Creamos el emailDATA						  var emailDATA = {							name: name,							surname: surname,							to: email,							hash: result.hash,							subject: 'Correo electr√≥nico de confirmaci√≥n de contacto de Toollife',							template: 'templates/confirmacion_contacto.ejs'						  };						  						  mail.enviarCorreo(emailDATA);						  async.parallel([							async.apply(arrancarTimeout, result.hash, 1000 * 60 * 60 * 24)						  ]);						  						  handlers.valid(result.generatePathUser, -2, isActive, req, res); //Llamamos a la siguiente funcion						});					}				});			  }			});		}	}  });}function validarUser(handlersAction, hash, req, res){  var cliente = crearCliente();  var query = 'SELECT p.idUser, p.pathUser FROM usuarios u NATURAL JOIN en_tramite t NATURAL JOIN perfil p WHERE t.hash =  \'' + hash +'\';';  var pathUser, idUser;  var isActive = 1;    //El primer paso es recuperar todos los datos que se usan para el usuario  cliente.query(query, function (err, results, fields) {	if (err){		console.log("Error DB: " + err);		handlersAction.error(err, res);	} else {		if(results.length == 0)			handlersAction.noValid(req, res);		else {			results.forEachAsync(function (next, row) {			  idUser = row.idUser;			  pathUser = row.pathUser;			  setTimeout(next, 0);			}).then(function (){				//El segundo paso es borrar el registro en_tramite, y activar al usuario				async.series({				  res1: executeQuery(cliente, 'START TRANSACTION;'),				  res2: executeQuery(cliente, 'DELETE FROM en_tramite WHERE hash = \'' + hash + '\';'),				  res3: executeQuery(cliente, 'UPDATE usuarios SET isActive = 1 WHERE idUser = \'' + idUser + '\';'),				  res4: executeQuery(cliente, 'COMMIT;'),				}, function(err, results) {					cliente.end();					if(err)						handlersAction.error(err, res);					else {						//El tercer paso es borrar el timer asociado a ese tramite						clearTimeout(tramites.indexOf(hash,1));						tramites.splice(tramites.indexOf(hash,1)); 												//El cuarto paso es actualizar el info.json del usuario						var userDATA = utils.createUserDataWithParameters(idUser, pathUser, isActive);						utils.updateFileInfo(userDATA);												//El quinto y ultimo paso es hacer login						handlersAction.valid(pathUser, idUser, isActive, req, res);					}				});			});		}	}  });}//Funciones con otras utilidades//Esta funcion crea el directorio personal, si no existe, y realiza las consultas que hagan faltafunction preparePageUser(userDATA){  utils.createDirectory(userDATA);    /*async.parallel([    async.apply(fs.writeFile, 'testfile1', 'test1'),    async.apply(fs.writeFile, 'testfile2', 'test2'),  ]);*/}function startTimers(){  //Arrancamos todos los timers que controla el servidor  monitor_Tramites = setTimeout(createTimeoutsEnTramite, 0);  monitor_Cookies_Caducadas = setTimeout(dropCookiesCaducadas, 0);}/** Permite llevar a cabo todas las funciones relacionadas con las cookies.	Valores para action: 1.Inserccion, 2.Borrado, 3.Update token.	Estructura de cookieDATA: idUser, serie, token.		Los errores en inserccion, borrado y update token no importan porque cuando vuelva a acceder, la cookie no sera valida 	y el usuario volvera a loguearse manualmente, no hay porque forzar a la bd a insertar, borrar o update token por cosas	como que la BD este caida o que el token o serie generado ya exista, son cosas que no ocurren casi nunca.  */function gestionCookie(action, cookieDATA){  var realizarAccion = true;  var query = null;    switch(action){	case 1: 		query = 'INSERT INTO remember_me (idUser, serie, token) VALUES (\'' + cookieDATA.idUser + '\', \'' + cookieDATA.serie + '\', \'' + cookieDATA.token + '\');';		break;	case 2: 		query = 'DELETE FROM remember_me WHERE idUser = \'' + cookieDATA.idUser + '\' AND serie = \'' + cookieDATA.serie + '\' AND token =  \'' + cookieDATA.token + '\';';		break;	case 3:		query = 'UPDATE remember_me SET token = \'' + cookieDATA.token + '\' WHERE idUser = \'' + cookieDATA.idUser + '\' AND serie = \'' + cookieDATA.serie + '\';';		break;	default:		realizarAccion = false;  }    if(realizarAccion){	var cliente = crearCliente();	async.series({		results: executeQuery(cliente, query)	}, function(err, data){		cliente.end();	});  }}function findCookieAndValid(res, req, cookie, cookieDATA, handler){	var query = 'CALL buscar_e_identificar_remember_me(' + cookieDATA.idUser + ', \'' + cookieDATA.serie + '\', \'' + cookieDATA.token + '\');';	var cliente = crearCliente();		async.series({		results: executeQuery(cliente, query)	}, function(err, data){		cliente.end();				if(data.results.length == 1) {			var pathUser, isActive = null;						data.results.forEachAsync(function (next, row) {				pathUser = row.pathUser;				isActive = row.isActive;				setTimeout(next, 0);			}).then(function () {				handler(res, req, true, cookie, cookieDATA, pathUser, isActive);			});		} else 			handler(res, req, false);	});}//Funciones auxiliaresfunction crearCliente(){  var cliente = mysql.createClient({	user: 'root',	password: 'tacens_69',	host: '127.0.0.1',	port: '3306',	database: 'toollifedb'  });	  return cliente;}function arrancarTimeout(hash, timeout){  var timeoutTramite = setTimeout(function (){	eliminarTramite(hash, timeout, timeoutTramite);  }, timeout);    tramites.push(timeoutTramite);  console.log("Timeout: " + timeout);  console.log("Timeouts tramites: " + tramites.length);}function eliminarTramite(hash, timeoutTramite){	//Borramos el tramite y el usuario asociado	var cliente = crearCliente();      async.series({		res1: executeQuery(cliente, 'START TRANSACTION;'),		res2: executeQuery(cliente, 'SELECT @id := e.idUser as idUser FROM en_tramite e WHERE e.hash = \'' + hash +'\';'),		res3: executeQuery(cliente, 'DELETE FROM en_tramite WHERE hash = \'' + hash + '\';'),		res4: executeQuery(cliente, 'SELECT pathUser FROM perfil WHERE idUser = @id;'),		res5: executeQuery(cliente, 'DELETE FROM usuarios WHERE idUser = @id;'),		res6: executeQuery(cliente, 'COMMIT;')	}, function(err, results) {		cliente.end();		if(err){			clearTimeout(timeoutTramite);			tramites.splice(tramites.indexOf(hash,1));			timeoutTramite = setTimeout(function (){				//Creamos un timeout que pruebe a realizar la accion dentro de una hora				eliminarTramite(hash, timeout, timeoutTramite);			}, 1000 * 60 * 60);			tramites.push(timeoutTramite);		} else {			var pathUser = null;			tramites.splice(tramites.indexOf(hash,1));						results.res4.forEachAsync(function (next, row) {				pathUser = row.pathUser;				setTimeout(next, 0);			}).then(function () {				utils.eliminarDirUsuario(pathUser);			});			console.log("Se ha borrado el hash " + hash + " quedan " + tramites.length);		}	});}function checkValue(str, name, min, max, checkEmail){  return function(callback) {    var result = utils.trimFirstAndLast(str);	var err = null;	var errSTR = 'El ' + name + ' debe tener entre ' + min + ' y ' + max + ' car√°cteres.';		if(result == null)		err = new Error('Debe rellenar todos los campos correctamente.');	else {		try {			if(checkEmail)				check(str, 'Email invalido.').len(min, max).isEmail();			else				check(str, errSTR).len(min, max);		} catch (e){ err = e; }	}		callback(err, result);  }}function executeQuery(cliente, query){  return function(callback) {	cliente.query(query, function (err, results, fields) {		if (err){			console.log("Error DB: " + err);			callback(err, null);		} else 			callback(null, results);	});  }}function existsUser(cliente, email){  return function(callback) {	var query = 'SELECT * FROM usuarios WHERE email = \'' + email + '\';';	cliente.query(query, function (err, results, fields) {		if (err){			console.log("Error DB: " + err);			callback(err.message, true);		} else {			var err = (results.length == 0)? null : 'El usuario ya existe.';			callback(err, (results.length == 0));		}	});  }}function generatePathUser(cliente, name, surname){  return function(callback) {	//Primero fabricaremos la url a partir del nombre y apellidos	var nombre = utils.trim(name.toLowerCase());	var apellidos = utils.trim(surname.toLowerCase());	var pathUser = utils.quitarTildesMinusculas(nombre + '.' + apellidos);	var query = 'SELECT * FROM perfil WHERE pathUser REGEXP \'^' + pathUser + '[0-9]*$\';';		//Despues comprobamos si existen usuarios con el mismo pathuser, si los hay le agregamos un numero total mas uno	cliente.query(query, function (err, results, fields) {		if (err){			console.log("Error DB: " + err);			callback(err.message, false);		} else {			pathUser = (results.length == 0)? pathUser : (pathUser + (results.length + 1));			callback(null, pathUser);		}	});  }}function createTimeoutsEnTramite(){  var cliente = crearCliente();  var query = 'CALL obtener_fecha_expiracion_validacion;';    cliente.query(query, function (err, results, fields) {	cliente.end();	if (err){		//Eliminamos el Timeout y lo volvemos a relanzar dentro de una hora		console.log(color(utils.getFechaStringForLog(), 'bold') + ' ' + color(err.message, "red"));		clearTimeout(monitor_Tramites);		monitor_Tramites = setTimeout(createTimeoutsEnTramite, 1000 * 60 * 60);	} else {		console.log(utils.getFechaStringForLog() + ' Tramites pendientes de validar: ' + results.length);		results.forEachAsync(function (next, row) {			var hash = row.hash;			var timeout = (row.timeout < 0)? 0 : row.timeout;			arrancarTimeout(hash, timeout);			setTimeout(next, 0);		});	}  });};function dropCookiesCaducadas(){  var cliente = crearCliente();  var query = 'CALL borrar_registros_rememberMe_caducadas;';    cliente.query(query, function (err, results, fields) {	cliente.end();	if (err){		//Eliminamos el Timeout y lo volvemos a relanzar dentro de una hora		console.log(color(utils.getFechaStringForLog(), 'bold') + ' ' + color(err.message, "red"));		clearTimeout(monitor_Cookies_Caducadas);		monitor_Cookies_Caducadas = setTimeout(dropCookiesCaducadas, 1000 * 60 * 60); //Cada hora se ejecutara	} else {		console.log(utils.getFechaStringForLog() + ' Remember-me caducados que se han borrado: ' + results.affectedRows);		clearTimeout(monitor_Cookies_Caducadas);		monitor_Cookies_Caducadas = setTimeout(dropCookiesCaducadas, 1000 * 60 * 60 * 24); //Cada 24 horas se ejecutara	}  });}function createHash(){  return function(callback){	var hash = utils.generateHash(1);	callback(null, hash);  }}/** Exports **/exports.verificarUser = verificarUser;exports.registrarUser = registrarUser;exports.validarUser = validarUser;exports.gestionCookie = gestionCookie;exports.findCookieAndValid = findCookieAndValid;exports.preparePageUser = preparePageUser;exports.startTimers = startTimers;